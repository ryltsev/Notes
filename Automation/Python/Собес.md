==Какие бывают типы данных в Python==
Изменяемые:
list, dict, set
Неизменяемые:
int, float, string, bool, None type, tuple, frozen set
==Чем отличаются операторы равно равно и is==
Равно сравнивает по значения, а is по адресам в памяти
==Как в Python передаются аргументы в функцию(изменяемые и неизменяемые)==
Неизменяемые передаются по значениям, изменяемые работают по ссылкам
==Что такое args и kwargs? Чем представлены?==
args (представлен в виде tuple) - это аргумент который принимает в себя неограниченное количество позиционных аргументов функции.
kwargs (представлен в виде dict) - это аргумент который принимает в себя неограниченное количество аргументов, которые мы передаём с помощью ключевых слов
==Что такое аннотации типов, зачем они нужны, когда выполняются?==
Это подсказки типом в аргуменат, переменным и тд
Нужны для понимания что ожидаем + пайчарм подсветит если ожидается одно, а передали другое.
Пайтон их не выполняет и по факту они только для информации
==Что такое лямбда функции и каковы кейсы её применения?==
Это анонимная функция(без имени), функция может принять неограниченное количество аргументов и в функции содержится неявный return
Обычно используется не как самостоятельная функция, а где другая функция может её принять, например filter, map
==Тернарный оператор, как записывается?==
Это обычный if, который мы записываем в одну строку для лаконичности и читаемости.
result = 1 if some else 0
==Что такое виртуальное окружение? Зачем оно нужно? Какие инструменты для этого используются?==
Позволяет настроить конкретный проект не засоряя глобальный python. Внутри окружения всегда используется именно те версии, что мы установили.
В python 3 используется venv
==Как оценивается сложность алгоритмов и почему? Что такое Big O notation?==
Сложность алгоритмов оценивается с точки зрения Big O notation. 
Если у нас есть цикл прохождения коллекции то это будет ...
Если это будет рекурсивное выполнение, то это логарифм
Если цикл в цикле, то квадратичная кубическая и тд
==Что такое класс?==
Это шаблон для уникальных экземпляров
==Что такое объект?==
Это уникальный экземпляр класса
==Что такое self в классах?==
self - это ссылка на текущий созданный уникальный объект класса
Нужен что бы понимать из какого объекта брать данные или вносить изменения
==Зачем нужен метод super  в классе?==
super нужен для доступа к родительским классам когда у нас есть наследование (условно это ссылка на объект родительской сущности).
==Как в python реализуются методы объекта, класса и статические методы? Чем они отличаются?==
Существуют 3 типа методов:
1. Методы объекта, принимает первым аргументом self как ссылку на текущий объект. Характеризуют поведение конкретного экземпляра. Можно вызвать только когда мы уже создали объект класса.
2. Методы класса, создаются с помощью декоратора @classmethod, первым аргументом принимает def foo(cls): cls - это ссылка на класс. Принадлежат к классу и характеризуют поведение всего этого класса. Можно вызвать сразу через класс, без создания объекта класса.
3. Статик методы, создаются с помощью декоратора @staticmethod def foo(): обязательных аргументов у него нет. Не относится ни к классу ни к объекту и помещается в класс только потому что подходит сюда по смыслу. Можно вызвать сразу через класс, без создания объекта класса.
==В python нет модификаторов доступа, все по умолчанию public. Как в python реализуются public, private и protected методы и атрибуты?==
В питоне все атрибуты public, но есть договорённости как обозначать защищённые атрибуты.
protected (называем с одного подчёркивания) - виден в текущем классе и в дочерних классах, но даже у самого объекта вызвать не можем.
private (называем с двух подчёркиваний) - доступны только внутри класса, в дочерних уже не видно.
==Что такое декораторы? Зачем нужны? Как реализовать в python простой декоратор и декоратор с пробросом аргумента?==
Декоратор - это паттерн проектирования и он реализуется через класс. С помощью этого класса меняется поведение какого-то кода без его исходного изменения.
В python, функции - это объекты первого класса.
В python всё объекты. Функция может принимать в качестве аргумента другую функцию и возвращать и возвращать эту функцию в качестве результирующего значения. Это и есть декораторы в python и для этого в python есть выделенный синтаксический сахар.
Замыкание - это когда функция возвращает другую функцию, что бы изменить поведение своих аргументов. Декоратор и есть замыкание.
==Что такое абстрактный класс? Зачем они нужны? Как они реализуются в Python?==
В питоне нет интерфейсов как в джаве и нам надо реализовать контракты между классами для этого используем абстрактные классы.
Абстрактный класс - это класс у которого нельзя создать объект.
Зачем нужен - в этом классе описывается контракт, который должны реализовать дочерние классы. Контракт в виде абстрактных методов.
``from abc import ABC, abstractmethod  
class A(ABC):  
    @abstractmethod  
    def some():  
        pass
==При наследовании в другой класс, метод остаётся абстрактным и сначала его необходимо переопределить и только потом можно будет создать объект класса.
Что такое метаклассы? Для чего используются? Какие методы там используются? Как реализовать на Python?==
Метаклассы - это шаблоны для классов. Нужны что бы перехватить создание класса и изменить его.
==Что такое ООП?==
Это парадигма когда мы код выстраиваем в виде совокупности объектов, которые являются экземплярами каких-то классов, а классы выстраивают иерархию какого-то наследования.
==Какие базовые принципы?==
Абстракция - говорит о том, что мы в коде используем только те характеристики объекта, которые нам важны конкретно в данном коде.
Наследование - дочерний класс строится на основе родительского класса и получает абсолютно всё от родительского класса (атрибуты, методы и тд)
Инкапсуляция - в программировании понимается двояко. 
1. Это о том, что мы в класс должны поместить все атрибуты и методы связанные общей идеей. Мы их инкапсулируем в класс и от класса с ними работаем.
2. В классе преимущественно должны быть защищённые атрибуты. Наружу отдаём только интерфейс, который потребуется пользователю.
Полиморфизм - в программировании понимается двояко. 
1. Параметрический полиморфизм (утиная типизация) - в функциях пофиг на типы данных прилетающие извне.
2. Используем одни и те же имена во всей структуре за счёт того, что мы можем в дочерних перегружать родительские методы модифицируя их функционал.
==Что такое миксины?==
Это мелкие классы с небольшим функционалом. И этот функционал нам нужен во многих классах. Во всех классах где нам нужен этот функционал, мы наследуем данный класс, который принято называть миксин.
==Что такое diamond problem? Что такое MRO (Method resolution ordering)? Чем отличается MRO2 от MRO3? Зачем оно нужно?==
Это жёсткий порядок разрешения зависимостей при наследовании. 
MRO2 в Python 2 использовал алгоритм поиска в глубине
MRO3 в Python 3 используется алгоритм поиска в ширину
Это список содержится внутри класса, можно посмотреть class.mro(), выводит список по которому будет искаться какой ни будь атрибут или метод.
==Что такое итератор? Что такое итерируемый объект?==
Итератор - это структура данных которая отдаёт что ни будь по 1.
Итерируемый объект - это объект по которому можно пройтись поэлементно.
Iter возвращает ссылку на итератор, а next возвращает следующий объект этой последовательности.
Почему 2 метода? Потому что их можно развести по разным классам.
==Что такое генератор? Как написать на Python генератор?==
Генератор - это функция у которой вместе return yield (штука которая умеет принимать и отдавать контроль управления).
При нескольких елдах будем получать следующие объекты генератора.
https://www.youtube.com/watch?v=BoazgBZ4D7k закончил на 1:30 после оффтопа
==Best practices==
KISS - keep it simple stupid (максимально простые функции)
DRY - don't repeat yourself (сколько раз мы повторили код, столько мест и придётся модифицировать в случае необходимости. Если код надо повторить, то он выносится в функцию и эта функция уже вызывается)
SOLID:
1. Single responsobility - принцип единичной ответственности - каждый класс должен выполнять только те цели для которых он был задуман.
2. Open closed - принцип открытости/закрытости - класс должен быть открыт для расширения и закрыт для модификации.
3. Lis... принцип барбари лиско - объект дочернего класса должен полностью уметь заменять объект родительского класса. То есть в функцию родительского класса можно кинуть функцию дочернего класса и это должно работать.
4. Interface aagregation - принцип разделения интерфейсов - лучше иметь кучу конкретных интерфейсов под конкретные нужды. Чем иметь один огромный интерфейс подо всё.
5. Dependency inversion - Должны быть зависимости на класса, а не классы на зависимостях. При новой реализации создаём новый класс и от него уже работаем.
